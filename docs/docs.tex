\documentclass{book}
\usepackage{listings}

\title{HLIM Language Manual}
\date{\today}
\author{Hourin}

\begin{document}

\maketitle
\tableofcontents

\frontmatter
\chapter{Introduction}
The HLIM is an interpreted programming language designed with a focus on
functional programming principles and syntactic minimalism. An environment
where gotchas and bugs happen due to syntactic gotchas is provided by reducing
the number of unique syntactic constructs.

The language, and by extension its first interpreter, is dynamic and
weakly typed. Types are bound to values at runtime rather than declared
identifiers. This is one of the biggest differences between HLIM and
conventional functional languages. This removes overhead for the interpreter
and the interpreter developer.

Branching via \texttt{if()} and looping via \texttt{loop()} is provided.
Early loop exiting can be done by forcefully making the loop condition
false. I reckon the inclusion of a dedicated exit statement would be great,
but it might clutter the control flow.

Having first-class functions, HLIM allows the user to freely pass a
function as an argument for other functions, and function to return
another function in order to compose bigger functions, and make the
functions more flexible. However, even though most of a higher-order
function/closure's functions are implemented including non-local variables
to some extents, capturing specific variables like in C++ or Rust is not
yet implemented.

\mainmatter
\chapter{Tutorial Introduction}
\section{Hello World}
The only way to proper learn a language is by writing programs in it.
In HLIM, the program to print "Hello World"

\begin{lstlisting}
print("Hello World\n")
\end{lstlisting}

HLIM is interpreted and therefore there's no need for compiling. However,
due to the limitations of Flex (the lexer used for HLIM), the only way to
run HLIM code is with Unix pipes:
\begin{lstlisting}
hlim < code.hlim
\end{lstlisting}

If your machine is working correctly, and it should, print the following
\begin{lstlisting}
Hello World
\end{lstlisting}

A HLIM program consists of only expressions and statements. An expression
is code that may have a return value, while a statement is code that doesn't.
HLIM executes code from top to bottom, one expression or statement at a time.
Everything is done in one parse, meaning it's not possible to reference
something declared after the executing statement.

\section{Bindings and Arithmetic expressions}
The following program declares a function that increments a value and
calls it:
\begin{lstlisting}
decl(inc { r0+1 })
print(inc(6) inc(8))
\end{lstlisting}

When you run the program, it should print 79.

Declaring a variable (binding) is done with the \texttt{decl()} function. It
requires a name (identifier) and a value. As mentioned, in HLIM, types are
assigned to a value rather than an identifier. You can redeclare the
identifier with a different value type, or assign an existing identifier
with a value of different type. There are 3 basic data types in HLIM:
numbers, strings, and blocks.
\begin{itemize}
    \item[Numbers] All numeric values are treated as single-precision
        32-bit floats.
    \item[Strings] An immutable sequence of ASCII characters.
    \item[Blocks] The most powerful type, used to represent anything from
        functions to lists and structures.
\end{itemize}

In contrary to conventional languages, HLIM does not provide the integer,
char and boolean types.

Arithmetic expressions in HLIM are, fortunately, done with infix notations.
This is a trade-off between readability and minimalistic syntax. A
minimalist language would use prefix (Lisp) or postfix (Forth), an older
iteration of HLIM used Lisp-like prefix, but this harms readability too much
for too little gain. When you write an arithmetic expression, the result is
returned. In HLIM, expressions are also statements and thus it doesn't complain
about unused expression results.

\begin{lstlisting}
5+6
\end{lstlisting}

The above code does nothing but holding the number 11 until it exits.

In the code at the start of the section, more usage of the built-in function
\texttt{print()}. \texttt{print()} will print everything supplied to it
as arguments. This includes all 3 basic data types, and some extra ones used
by FFI features of the language. \texttt{print()} can also print a
function's AST because it's a Block.

\section{Call versus non-call}
Before discussing control flows, it's essential to understand Blocks and
deferred execution. Without mentioning this, you will never understand why
your loops don't run.

In HLIM, curly braces \texttt{\{\}} \textbf{do not} denote a simple scope
or a statement list like in C. Instead they define a Block value.

A Block is a collection of expressions whose execution is \textbf{deferred}.
Because HLIM is a single-pass interpreter, expressions are linked via a
\texttt{next} pointer. When the interpreter encounters a Block, it treats the
entire sequence as a single value and skips over it without evaluating its
contents.

Consider the following code, where a programmer coming from C might expect
it to print 5 and then 10:
\begin{lstlisting}
decl(x 10)
{
    decl(x 5)
    print(x "\n")
}
print(x "\n")
\end{lstlisting}

When running the program, you will notice that it only prints 10 once.
The middle section (the Block) is evaluated as a value (a Block) but
never invoked (evaluated). Its internal expressions are not evaluated.
I call this a non-call block. For predictability, in HLIM a Block is
always a non-call block, even if it might look better to have its content
be automatically evaluated in few cases.

The correct solution is to call the Block. This is a technique called
"IIFE" (Immediately Invoked Function Expression), commonly used to provide
a statement list or a scope in languages supporting closures but lacking
syntax for scope. You can use the call syntax \texttt{()} to call it:
\begin{lstlisting}
decl(x 10)
{
    decl(x 5)
    print(x "\n")
}() // Look here
print(x "\n")
\end{lstlisting}

Output:
\begin{lstlisting}
5
10
\end{lstlisting}

You can see more of call and non-call in action here:
\begin{lstlisting}
decl(func { r0 + 10 * 2 })
decl(x { print("this is x\n") func(3) + func(4) * 2 }() )
print(x)
\end{lstlisting}

Output:
\begin{lstlisting}
this is x
71
\end{lstlisting}

The execution order, expression by expression:
\begin{enumerate}
    \item A block is bound to identifier \texttt{func}.
        It's non-call and thus not executed.
    \item Identifier \texttt{x} is declared. To determine the
        value of \texttt{x}, the interpreter evaluates the
        expression on the right.
    \item Due to the call syntax (trailing \texttt{()}), the block
        is evaluated immediately (IIFE).
        \begin{enumerate}
            \item \texttt{print("this is x\textbackslash")} is run.
            \item The math is calculated: \textit{func(3)=23},
                \textit{func(4)=24}
            \item The result (71) is returned and bound to \texttt{x}.
        \end{enumerate}
    \item Finally, \texttt{print(x)} is executed and 71 is put
        on the terminal
\end{enumerate}

\section{Control flows}
With Blocks and calls clearly explained, we can move on to control flows.

\subsection{if-else}
Here's a function that prints a number if it's even, and prints
"boo" otherwise:
\begin{lstlisting}
decl(print_if_odd {
    decl(mod r0%2)
    if(mod==1 print(r0 "\n") print("boo\n"))
})
\end{lstlisting}

The \texttt{if} operates as follows: the condition (the 1st expression) is
first evaluated, if it's true, the \texttt{do} branch (the 2nd expression)
is evaluated. Otherwise, the 3rd expression (\texttt{otherwise} branch) is
evaluated if it exists.

In HLIM, the condition is considered true only if:
\begin{itemize}
    \item The numeric expression is bigger than 0.
    \item FFI handle and FFI symbol is valid
        (will be mentioned later)
\end{itemize}

The rules of calls vs non-calls still apply to \texttt{if}:
\begin{lstlisting}
if(condition {
    // do a bunch of things...
}()) // <-- notice the trailing call operator
\end{lstlisting}

In an older iteration, blocks passed to \texttt{if} and \texttt{loop} are
automatically executed without the call operator. This created headaches
where \texttt{if} returning a Block is desired and was thus removed.

Because \texttt{if} returns the expression result of the evaluated branch,
it functions naturally as a ternary operator:
\begin{lstlisting}
decl(status if(is_logged_in "Welcome" "Login"))
\end{lstlisting}

You can use the non-call to create something like this:
\begin{lstlisting}
decl(func if(x { print("hi world\n") }))
\end{lstlisting}
where func becomes a function that when called, prints "hi world" if
x is true, and an empty statement otherwise.

Because the language is dynamic and weakly typed, one can do something
like this without any errors or warnings:
\begin{lstlisting}
decl(func if(x { print("hi world\n") } 5))
\end{lstlisting}
however it might not be desired as applying call syntax on a number
returns NIL (nothing, similar to void) instead of that number.

\subsection{loop}
A loop syntax is similar to that of branching. Here's the program
to print the multiplication table of 4:
\begin{lstlisting}
decl(x 1)
loop(x!=11 {
    print(x "*" 4 "=" x*4 "\n")
    asn(x x+1)
}())
\end{lstlisting}

A loop will evaluate the condition first. If it's true, then the loop
body (2nd expression) will be evaluated (non-call rules apply). Otherwise
it moves to the next expression without evaluating the body. Usually you'd
want the loop body to do something, while not accidentally making it an
infinite loop, so get in the habit of adding a trailing call whenever
you want a loop.

Similar to \texttt{if}, in the older iteration, the loop body is also
automatically executed. I'm debating whether to bring it back as the
loop itself doesn't evaluate to anything.

However, note that a loop is the only statement that's not an expression
in the language. A loop will not have return value and expression results.
Meaning, the following code will error from the parsing phase:
\begin{lstlisting}
decl(x 5)
decl(z loop(x { x asn(x-1) }()))
print(z)
\end{lstlisting}
consequentially, you cannot use it as arguments for function calls.

There's no such things as \texttt{for(int i=0;i<10;i++)} in HLIM. A loop
is a pure loop, and it loops until the condition is false. However by
applying the concepts learnt earlier, one can extend the language with
this feature by writing this function:
\begin{lstlisting}
decl(repeat {
    decl(x r0)
    loop(x {
        r1()
        asn(x x-1)
    }())
})
\end{lstlisting}

The above function takes a number and a block, then repeat that block
N times. However be careful not to get it something other than an integer.

\section{decl and asn}
HLIM provides 2 methods to change a variable's value at runtime:
\texttt{decl()} and \texttt{asn()}. This section goes into the
differences between the 2.

\subsection{decl}
\texttt{decl()}, as its name suggests, declares an identifier and binds
a value to it.

Subsequent uses of decl within the same scope will overwrite the value
of the identifier, whereas if used in a scope, it will create a new
local identifier, which temporarily shadows the identifier with the
same name in the outer scope, and is removed when the scope exits.

HLIM also uses lexical scoping as opposed to the older version that
uses dynamic scoping, and is thus more predictable.

\subsection{asn}
\texttt{asn()}, like its name suggests, assigns a new value to the
identifier.

Because it doesn't create an identifier, when requested to assign
new value to something that doesn't exist, it does nothing, and the
non-existent identifier remains undefined (outputs NIL when printed).

As opposed to decl, when used within a local scope, asn will modify
the value of an identifier declared in outer scopes if it's not
already declared in local scope. That's why we usually use asn to
increment counters in a loop statement.

\subsection{Comparison}
The following code demonstrates how asn and decl interacts with
closures/scopes/blocks:
\begin{lstlisting}
decl(x 10)
{
    decl(x 5)     // Shadowing: creates new local x
    print(x "\n") // Prints 5
    asn(x 6)      // Updates local x (6)
    print(x "\n") // Prints 6
}()
print(x "\n")     // Prints 10 (outer x was never touched)

{
    asn(x 20)     // No local x: updates outer x
}()
print(x "\n")     // Prints 20
\end{lstlisting}

\chapter{Advanced syntax and features}
In this chapter, we cover some more advanced features such
as things that make HLL a functional language, and how to
call an FFI function.

\section{Expression grouping and precedence}

\section{Pipelines}

\section{Function parameters}
\subsection{Named parameters}

\section{List indexing}

\section{Optimization requests}

\section{Tags}

\section{FFI (Foreign function interface)}

\end{document}

